load("@bazel_skylib//rules:copy_file.bzl", "copy_file")
load("@bazel_skylib//rules:run_binary.bzl", "run_binary")
load("//bazel/toolchain:objcopy.bzl", "objcopy_to_bin")
load("//bazel/util:transition.bzl", "rp2040_bootloader_binary")

package(default_visibility = ["//visibility:private"])

cc_library(
    name = "config",
    hdrs = [
        "asminclude/boot2_helpers/exit_from_boot2.S",
        "asminclude/boot2_helpers/read_flash_sreg.S",
        "asminclude/boot2_helpers/wait_ssi_ready.S",
        "boot2_at25sf128a.S",
        "boot2_generic_03h.S",
        "boot2_is25lp080.S",
        "boot2_usb_blinky.S",
        "boot2_w25q080.S",
        "boot2_w25x10cl.S",
        "include/boot_stage2/config.h",
    ],
    includes = [
        "asminclude",
        "include",
    ],
    target_compatible_with = select({
        "//bazel/constraint:rp2": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
    visibility = ["//src/rp2_common/pico_standard_link:__pkg__"],
)

# Stub library to prevent custom malloc from getting linked in. boot2 will never
# need malloc, so letting it link can only cause problems.
cc_library(
    name = "no_malloc",
)

cc_binary(
    name = "boot_stage2_elf_actual",
    srcs = ["compile_time_choice.S"],
    copts = ["-fPIC"],
    linkopts = [
        "-Wl,--no-gc-sections",
        "-nostartfiles",
        "-T$(location boot_stage2.ld)",
    ],
    # this does nothing if someone passes --custom_malloc, so the
    # rp2040_bootloader_binary transition forcibly clobbers --custom_malloc.
    malloc = ":no_malloc",
    tags = ["manual"],
    target_compatible_with = select({
        "//bazel/constraint:rp2": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
    deps = [
        "boot_stage2.ld",
        ":config",
        "//src/common/pico_base:pico_base_interface",
        "//src/common/pico_base:pico_platform",
    ],
)

# Always build the bootloader with the bootloader-specific platform.
rp2040_bootloader_binary(
    name = "boot_stage2_elf",
    src = "boot_stage2_elf_actual",
)

objcopy_to_bin(
    name = "boot_stage2_bin",
    src = ":boot_stage2_elf",
    out = "boot_stage2.bin",
    target_compatible_with = select({
        "//bazel/constraint:rp2": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
)

# WORKAROUND: Python rules always require a .py extension.
copy_file(
    name = "copy_tool_to_py",
    src = "pad_checksum",
    out = "pad_checksum_tool.py",
    target_compatible_with = ["//bazel/constraint:host"],
)

py_binary(
    name = "pad_checksum_tool",
    srcs = ["pad_checksum_tool.py"],
    target_compatible_with = ["//bazel/constraint:host"],
)

run_binary(
    name = "boot_stage2_padded",
    srcs = [":boot_stage2_bin"],
    outs = ["boot_stage2.S"],
    args = [
        "-s 0xffffffff",
        "$(location boot_stage2_bin)",
        "$(location boot_stage2.S)",
    ],
    target_compatible_with = select({
        "//bazel/constraint:rp2": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
    tool = ":pad_checksum_tool",
)

cc_library(
    name = "boot_stage2",
    srcs = [":boot_stage2_padded"],
    target_compatible_with = select({
        "//bazel/constraint:rp2": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
    visibility = ["//visibility:public"],
    # This isn't referenced as a symbol, so alwayslink is required to ensure
    # it doesn't get dropped before the linker script can find it.
    alwayslink = True,
)
